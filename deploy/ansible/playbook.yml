# =============================================================================
# Storm Cloud Server - Deployment Playbook
# =============================================================================
#
# One-command deployment for Storm Cloud Server.
#
# Usage:
#   make deploy                    # From project root
#   make deploy-check              # Dry run (no changes)
#   make deploy-app                # Update app only
#
# Manual:
#   cd deploy/ansible
#   ansible-playbook playbook.yml -i inventory.yml --extra-vars "@../config.yml"
#
# =============================================================================

---
- name: Deploy Storm Cloud Server
  hosts: all
  become: true

  vars:
    app_user: "{{ app_user | default('stormcloud') }}"
    install_path: "/home/{{ app_user }}/storm-cloud-server"

  # ===========================================================================
  # PRE-FLIGHT
  # ===========================================================================

  pre_tasks:
    # Set default values for optional configuration variables
    # This prevents recursive template loops and makes defaults explicit
    - name: Set default values for optional variables
      ansible.builtin.set_fact:
        _web_port: "{{ web_port | default('8000') }}"
        _cors_origins: "{{ cors_origins | default('') }}"
        _max_upload_size_mb: "{{ max_upload_size_mb | default('100') }}"
      tags: [always]

    # -------------------------------------------------------------------------
    # Secret Resolution: Read from environment variables
    # -------------------------------------------------------------------------

    - name: Read secrets from environment variables
      ansible.builtin.set_fact:
        postgres_password: "{{ lookup('env', 'STORMCLOUD_POSTGRES_PASSWORD') }}"
        secret_key_input: "{{ lookup('env', 'STORMCLOUD_SECRET_KEY') }}"
        storage_encryption_key: "{{ lookup('env', 'STORMCLOUD_ENCRYPTION_KEY') | default('', true) }}"
        storage_encryption_method: "{{ 'server' if (lookup('env', 'STORMCLOUD_ENCRYPTION_KEY') | default('', true) | length > 0) else 'none' }}"
        storage_encryption_key_id: "{{ lookup('env', 'STORMCLOUD_ENCRYPTION_KEY_ID') | default('1', true) }}"
        # Email settings (from .env, override config.yml if set)
        email_host_env: "{{ lookup('env', 'EMAIL_HOST') | default('', true) }}"
        email_port_env: "{{ lookup('env', 'EMAIL_PORT') | default('587', true) }}"
        email_use_tls_env: "{{ lookup('env', 'EMAIL_USE_TLS') | default('true', true) }}"
        email_user_env: "{{ lookup('env', 'EMAIL_HOST_USER') | default('', true) }}"
        email_password_env: "{{ lookup('env', 'EMAIL_HOST_PASSWORD') | default('', true) }}"
      no_log: true
      tags: [always]

    - name: Set email config (env vars override config.yml)
      ansible.builtin.set_fact:
        email_host: "{{ email_host_env if email_host_env | length > 0 else (email_host | default('')) }}"
        email_port: "{{ email_port_env if email_host_env | length > 0 else (email_port | default(587)) }}"
        email_use_tls: "{{ email_use_tls_env if email_host_env | length > 0 else (email_use_tls | default(true)) }}"
        email_user: "{{ email_user_env if email_host_env | length > 0 else (email_user | default('')) }}"
        email_password: "{{ email_password_env if email_host_env | length > 0 else (email_password | default('')) }}"
      no_log: true
      tags: [always]

    - name: Auto-generate SECRET_KEY if not provided
      ansible.builtin.set_fact:
        secret_key_generated: "{{ lookup('password', '/dev/null length=50 chars=ascii_letters,digits,punctuation') }}"
      when: secret_key_input | default('') | length == 0
      no_log: true
      tags: [always]

    - name: Set final SECRET_KEY
      ansible.builtin.set_fact:
        secret_key: "{{ secret_key_input if (secret_key_input | default('') | length > 0) else secret_key_generated }}"
      no_log: true
      tags: [always]

    - name: Show auto-generated SECRET_KEY (save this somewhere safe!)
      ansible.builtin.debug:
        msg: |
          
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          âš ï¸  AUTO-GENERATED SECRET_KEY
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          Your Django SECRET_KEY has been auto-generated:
          
          {{ secret_key }}
          
          âš ï¸  SAVE THIS SOMEWHERE SAFE (password manager, encrypted file)
          
          To use the same key in future deployments:
            export STORMCLOUD_SECRET_KEY="{{ secret_key }}"
          
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      when: secret_key_input | default('') | length == 0
      tags: [always]

    - name: Validate config
      ansible.builtin.assert:
        that:
          - server_ip | default('') | length > 0
          - domain | default('') | length > 0
          - admin_email | default('') | length > 0
        fail_msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          âŒ Missing required config
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          Edit deploy/config.yml and set:

            server_ip:    {{ server_ip | default('(empty)') }}
            domain:       {{ domain | default('(empty)') }}
            admin_email:  {{ admin_email | default('(empty)') }}

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      tags: [always]

    - name: Validate secrets
      ansible.builtin.assert:
        that:
          - postgres_password | default('') | length > 0
          - secret_key | default('') | length > 0
        fail_msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          âŒ STORMCLOUD_POSTGRES_PASSWORD is required
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          Set secrets as environment variables before deploying:

            export STORMCLOUD_POSTGRES_PASSWORD="your-secure-password"
            export STORMCLOUD_SECRET_KEY="your-django-secret-key"  # Optional (will auto-generate)
            make deploy

          Or you will be prompted for them during deployment.

          Generate a secure password:
            openssl rand -base64 32

          Need help? See: deploy/README.md#secrets
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      tags: [always]

    - name: Validate encryption key format (early check)
      ansible.builtin.command:
        cmd: python3 -c "import base64; key=base64.urlsafe_b64decode('{{ storage_encryption_key }}' + '=='); assert len(key)==32, f'Key must be 32 bytes, got {len(key)}'"
      delegate_to: localhost
      register: key_validation_early
      failed_when: false
      changed_when: false
      when: storage_encryption_key | default('') | length > 0
      tags: [always]

    - name: Fail early on invalid encryption key format
      ansible.builtin.assert:
        that:
          - key_validation_early.rc == 0
        fail_msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          âŒ INVALID ENCRYPTION KEY FORMAT
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          STORMCLOUD_ENCRYPTION_KEY is not valid base64url or wrong length.

          Generate a valid key with:
            python -c "import secrets; print(secrets.token_urlsafe(32))"

          Common issues:
            - Extra whitespace or newline when copying
            - Key was truncated
            - Wrong characters in the key

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      when: storage_encryption_key | default('') | length > 0
      tags: [always]

    - name: Check if nginx is already installed
      ansible.builtin.command: which nginx
      register: nginx_preinstalled
      failed_when: false
      changed_when: false
      tags: [always]

    - name: Detect existing nginx configurations
      ansible.builtin.find:
        paths: /etc/nginx/sites-enabled
        file_type: any
      register: existing_nginx_configs
      when: nginx_preinstalled.rc == 0
      tags: [always]

    - name: Warn about existing nginx installation
      ansible.builtin.pause:
        prompt: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          âš ï¸  EXISTING NGINX INSTALLATION DETECTED
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          Found {{ existing_nginx_configs.matched | default(0) }} existing config(s) in /etc/nginx/sites-enabled/

          Storm Cloud will:
          1. Remove /etc/nginx/sites-enabled/default (if exists)
          2. Remove /etc/nginx/sites-enabled/stormcloud (old symlink without .conf)
          3. Create /etc/nginx/sites-enabled/stormcloud.conf

          âš ï¸  Other existing configs will NOT be removed automatically.
          âš ï¸  If you have CloudPanel or other control panels, conflicts may occur.

          The following configs currently exist:
          {% for item in existing_nginx_configs.files %}
            - {{ item.path }}
          {% endfor %}

          Press ENTER to continue or Ctrl+C then 'A' to abort...

      when:
        - nginx_preinstalled.rc == 0
        - existing_nginx_configs.matched | default(0) > 0
      tags: [always]

    - name: Show deployment info
      ansible.builtin.debug:
        msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          Deploying Storm Cloud Server

            Server:  {{ server_ip }}
            Domain:  {{ domain }}
            User:    {{ app_user }}
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      tags: [always]

  # ===========================================================================
  # ROLES
  # ===========================================================================

  roles:
    - role: geerlingguy.docker
      when: install_docker | default(true)
      vars:
        docker_users: ["{{ app_user }}"]
      tags: [docker]

  # ===========================================================================
  # TASKS
  # ===========================================================================

  tasks:
    # -------------------------------------------------------------------------
    # System
    # -------------------------------------------------------------------------

    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600
      tags: [system]

    - name: Install packages
      ansible.builtin.apt:
        name: [git, curl, ufw, acl]
        state: present
      tags: [system]

    - name: Create app user
      ansible.builtin.user:
        name: "{{ app_user }}"
        shell: /bin/bash
        groups: docker
        append: true
      tags: [system]

    - name: Create persistent data directories (outside git repo)
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: "{{ app_user }}"
        mode: "0750"
      loop:
        - /var/stormcloud
        - /var/stormcloud/uploads
        - /var/stormcloud/backups
      tags: [system, app]

    # -------------------------------------------------------------------------
    # Data Directory Validation (prevent data loss)
    # -------------------------------------------------------------------------

    - name: Validate uploads directory exists
      ansible.builtin.stat:
        path: /var/stormcloud/uploads
      register: uploads_dir
      tags: [app, validation]

    - name: Fail if uploads directory missing
      ansible.builtin.fail:
        msg: |
          CRITICAL: /var/stormcloud/uploads does not exist!
          This could indicate a serious configuration problem.
          Run the playbook with 'system' tag first to create directories.
      when: not uploads_dir.stat.exists
      tags: [app, validation]

    - name: Test uploads directory is writable
      ansible.builtin.file:
        path: /var/stormcloud/uploads/.write_test
        state: touch
        owner: "{{ app_user }}"
      tags: [app, validation]

    - name: Remove write test file
      ansible.builtin.file:
        path: /var/stormcloud/uploads/.write_test
        state: absent
      tags: [app, validation]

    - name: Count files in uploads directory
      ansible.builtin.find:
        paths: /var/stormcloud/uploads
        recurse: yes
        file_type: file
      become: true
      become_user: "{{ app_user }}"
      register: uploads_files
      tags: [app, validation]

    # =========================================================================
    # DATA MIGRATION: Move files from old locations (inside repo) to persistent storage
    # =========================================================================
    # Previous versions stored files in:
    #   - ./storage_root/ (Django STORMCLOUD_STORAGE_ROOT default)
    #   - ./uploads/ (some Docker setups)
    # Git operations would wipe these directories. This migration moves files
    # to /var/stormcloud/uploads BEFORE any git operations happen.
    # =========================================================================

    - name: Check for files in storage_root (old Django default)
      ansible.builtin.find:
        paths: "{{ install_path }}/_core/storage_root"
        recurse: yes
        file_type: file
      become: true
      become_user: "{{ app_user }}"
      register: old_storage_root_files
      failed_when: false
      tags: [app, validation, migration]

    - name: Check for files in uploads (old Docker mount)
      ansible.builtin.find:
        paths: "{{ install_path }}/uploads"
        recurse: yes
        file_type: file
      become: true
      become_user: "{{ app_user }}"
      register: old_uploads_files
      failed_when: false
      tags: [app, validation, migration]

    - name: Migrate from storage_root to persistent location
      when:
        - old_storage_root_files.matched is defined
        - old_storage_root_files.matched > 0
        - uploads_files.matched == 0
      block:
        - name: Notify about storage_root migration
          ansible.builtin.debug:
            msg: |

              â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              ðŸ“¦ MIGRATING {{ old_storage_root_files.matched }} FILES FROM storage_root
              â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

              Moving files from:
                {{ install_path }}/storage_root/

              To persistent location:
                /var/stormcloud/uploads/

              This prevents data loss during git operations.
              â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        - name: Copy files from storage_root to persistent location
          ansible.builtin.shell: |
            rsync -av --remove-source-files {{ install_path }}/_core/storage_root/ /var/stormcloud/uploads/
          become: true
          become_user: "{{ app_user }}"
          register: rsync_storage_root

        - name: Clean up empty directories in storage_root
          ansible.builtin.shell: |
            find {{ install_path }}/_core/storage_root -type d -empty -delete 2>/dev/null || true
          become: true
          become_user: "{{ app_user }}"

        - name: Report storage_root migration
          ansible.builtin.debug:
            msg: "âœ“ Migrated {{ old_storage_root_files.matched }} files from storage_root"
      tags: [app, validation, migration]

    - name: Migrate from uploads to persistent location
      when:
        - old_uploads_files.matched is defined
        - old_uploads_files.matched > 0
        - uploads_files.matched == 0
        - (old_storage_root_files.matched | default(0)) == 0
      block:
        - name: Notify about uploads migration
          ansible.builtin.debug:
            msg: |

              â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              ðŸ“¦ MIGRATING {{ old_uploads_files.matched }} FILES FROM uploads
              â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

              Moving files from:
                {{ install_path }}/uploads/

              To persistent location:
                /var/stormcloud/uploads/

              This prevents data loss during git operations.
              â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        - name: Copy files from uploads to persistent location
          ansible.builtin.shell: |
            rsync -av --remove-source-files {{ install_path }}/uploads/ /var/stormcloud/uploads/
          become: true
          become_user: "{{ app_user }}"
          register: rsync_uploads

        - name: Clean up empty directories in uploads
          ansible.builtin.shell: |
            find {{ install_path }}/uploads -type d -empty -delete 2>/dev/null || true
          become: true
          become_user: "{{ app_user }}"

        - name: Report uploads migration
          ansible.builtin.debug:
            msg: "âœ“ Migrated {{ old_uploads_files.matched }} files from uploads"
      tags: [app, validation, migration]

    - name: Re-count uploads after potential migration
      ansible.builtin.find:
        paths: /var/stormcloud/uploads
        recurse: yes
        file_type: file
      become: true
      become_user: "{{ app_user }}"
      register: uploads_final
      tags: [app, validation]

    - name: Warn if uploads directory is empty
      ansible.builtin.pause:
        prompt: |

          âš ï¸  WARNING: /var/stormcloud/uploads contains {{ uploads_final.matched }} files.

          If this is NOT a fresh deployment, this could indicate DATA LOSS.

          Continue deployment? Type 'yes' to continue or Ctrl+C to abort:
      when:
        - uploads_final.matched == 0
        - not (skip_empty_warning | default(false) | bool)
      register: empty_warning
      tags: [app, validation]

    - name: Abort if user declines
      ansible.builtin.fail:
        msg: "Deployment aborted by user due to empty uploads directory"
      when:
        - empty_warning.user_input is defined
        - empty_warning.user_input | lower != 'yes'
      tags: [app, validation]

    # -------------------------------------------------------------------------
    # Firewall
    # -------------------------------------------------------------------------

    - name: Allow SSH
      community.general.ufw:
        rule: allow
        name: OpenSSH
      when: configure_firewall | default(true)
      tags: [firewall]

    - name: Allow HTTP
      community.general.ufw:
        rule: allow
        port: "80"
      when: configure_firewall | default(true)
      tags: [firewall]

    - name: Allow HTTPS
      community.general.ufw:
        rule: allow
        port: "443"
      when: configure_firewall | default(true)
      tags: [firewall]

    - name: Enable firewall
      community.general.ufw:
        state: enabled
        policy: deny
      when: configure_firewall | default(true)
      tags: [firewall]

    # -------------------------------------------------------------------------
    # Nginx (initial)
    # -------------------------------------------------------------------------

    - name: Install nginx
      ansible.builtin.apt:
        name: nginx
        state: present
      when: install_nginx | default(true)
      tags: [nginx]

    - name: Create certbot webroot
      ansible.builtin.file:
        path: /var/www/certbot
        state: directory
        mode: "0755"
      tags: [nginx]

    - name: Check if SSL cert exists
      ansible.builtin.stat:
        path: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      register: ssl_cert
      tags: [nginx, ssl]

    - name: Deploy pre-SSL nginx config
      ansible.builtin.copy:
        dest: /etc/nginx/sites-available/stormcloud
        mode: "0644"
        content: |
          server {
              listen 80;
              server_name {{ domain }};

              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }

              location / {
                  return 200 'Storm Cloud - awaiting SSL\n';
                  add_header Content-Type text/plain;
              }
          }
      when:
        - install_nginx | default(true)
        - not ssl_cert.stat.exists | default(true)
      notify: Reload nginx
      tags: [nginx]

    - name: Enable site
      ansible.builtin.file:
        src: /etc/nginx/sites-available/stormcloud
        dest: /etc/nginx/sites-enabled/stormcloud.conf
        state: link
      when: install_nginx | default(true)
      notify: Reload nginx
      tags: [nginx]

    - name: Remove default site
      ansible.builtin.file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: Reload nginx
      tags: [nginx]

    - name: Remove old stormcloud symlink (without .conf extension)
      ansible.builtin.file:
        path: /etc/nginx/sites-enabled/stormcloud
        state: absent
      notify: Reload nginx
      tags: [nginx]

    - name: Start nginx
      ansible.builtin.service:
        name: nginx
        state: started
        enabled: true
      when: install_nginx | default(true)
      tags: [nginx]

    - name: Flush handlers for certbot
      ansible.builtin.meta: flush_handlers
      tags: [nginx, ssl]

    # -------------------------------------------------------------------------
    # SSL
    # -------------------------------------------------------------------------

    - name: Install certbot
      ansible.builtin.apt:
        name: [certbot, python3-certbot-nginx]
        state: present
      when: install_certbot | default(true)
      tags: [ssl]

    - name: Get SSL certificate
      ansible.builtin.command:
        cmd: >-
          certbot certonly --webroot
          --webroot-path=/var/www/certbot
          --email {{ admin_email }}
          --agree-tos --no-eff-email --non-interactive
          -d {{ domain }}
        creates: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      when: install_certbot | default(true)
      tags: [ssl]

    - name: Re-check SSL cert
      ansible.builtin.stat:
        path: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      register: ssl_cert_final
      tags: [nginx, ssl]

    - name: Deploy full nginx config
      ansible.builtin.template:
        src: templates/nginx-stormcloud.conf.j2
        dest: /etc/nginx/sites-available/stormcloud
        mode: "0644"
      when:
        - install_nginx | default(true)
        - ssl_cert_final.stat.exists
      notify: Reload nginx
      tags: [nginx, ssl]

    # -------------------------------------------------------------------------
    # Application
    # -------------------------------------------------------------------------

    - name: Check if git repo exists
      ansible.builtin.stat:
        path: "{{ install_path }}/.git"
      become: true  # Need elevated permissions to check ownership
      register: git_dir
      tags: [app]

    - name: Check if install directory exists
      ansible.builtin.stat:
        path: "{{ install_path }}"
      become: true  # Need elevated permissions to check ownership
      register: install_dir
      tags: [app]

    # ADD THIS RIGHT HERE
    - name: DEBUG stat results
      ansible.builtin.debug:
        var: install_dir
      tags: [app]

    # =========================================================================
    # Pre-Deploy Backup (optional - prevents data loss)
    # =========================================================================
    # Run with: make deploy EXTRA_VARS="backup_before_deploy=true"
    # =========================================================================

    - name: Create pre-deploy backup
      when:
        - backup_before_deploy | default(false) | bool
        - install_dir.stat.exists | default(false)
      block:
        - name: Check if backup script exists
          ansible.builtin.stat:
            path: "{{ install_path }}/scripts/backup.sh"
          register: backup_script

        - name: Run backup script
          ansible.builtin.shell: |
            cd {{ install_path }}
            bash scripts/backup.sh
          become: true
          become_user: "{{ app_user }}"
          when: backup_script.stat.exists
          register: backup_result

        - name: Log backup result
          ansible.builtin.debug:
            msg: "Pre-deploy backup created successfully"
          when: backup_result is succeeded
      tags: [app, backup]

    - name: Download backup to local machine
      when:
        - backup_before_deploy | default(false) | bool
        - download_backup | default(true) | bool
        - backup_result is defined
        - backup_result is succeeded
      block:
        - name: Find latest backup files
          ansible.builtin.find:
            paths: /var/stormcloud/backups
            patterns: "stormcloud_backup_*.sql,stormcloud_backup_*.tar.gz,stormcloud_backup_*.txt"
            age: "-5m"
          become: true
          become_user: "{{ app_user }}"
          register: backup_files

        - name: Create local backup directory
          ansible.builtin.file:
            path: "{{ playbook_dir }}/../local_backups"
            state: directory
          delegate_to: localhost
          become: false

        - name: Download backup files
          ansible.builtin.fetch:
            src: "{{ item.path }}"
            dest: "{{ playbook_dir }}/../local_backups/"
            flat: yes
          loop: "{{ backup_files.files }}"
          when: backup_files.matched > 0

        - name: Report downloaded files
          ansible.builtin.debug:
            msg: "âœ“ Downloaded {{ backup_files.matched }} backup files to deploy/local_backups/"
      tags: [app, backup]

    # =========================================================================
    # Git Recovery - Handle broken deployment states
    # =========================================================================
    # If directory exists but .git is missing, we have a partial deployment.
    # Instead of nuking the directory (losing .env, uploads/),
    # we initialize git in-place and hard reset to the target branch.
    # =========================================================================

    - name: Fix directory ownership (if owned by root)
      ansible.builtin.file:
        path: "{{ install_path }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        recurse: true
      become: true
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
        - install_dir.stat.pw_name is defined and install_dir.stat.pw_name == 'root'
      tags: [app, git-recovery]

    - name: Initialize git repository (recovery mode)
      ansible.builtin.command:
        cmd: git init
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_init_result
      changed_when: "'Initialized' in git_init_result.stdout or 'Reinitialized' in git_init_result.stdout"
      tags: [app, git-recovery]

    - name: Add remote origin (recovery mode)
      ansible.builtin.command:
        cmd: "git remote add origin {{ repo_url | default('https://github.com/smattymatty/storm-cloud-server.git') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_remote_result
      failed_when: false  # Ignore error if remote already exists
      changed_when: git_remote_result.rc == 0
      tags: [app, git-recovery]

    - name: Set remote URL (if remote already existed)
      ansible.builtin.command:
        cmd: "git remote set-url origin {{ repo_url | default('https://github.com/smattymatty/storm-cloud-server.git') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
        - git_remote_result is defined and git_remote_result.rc != 0
      tags: [app, git-recovery]

    - name: Fetch from remote (recovery mode)
      ansible.builtin.command:
        cmd: "git fetch origin {{ git_branch | default('main') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_fetch_result
      changed_when: true
      tags: [app, git-recovery]

    - name: Hard reset to target branch (recovery mode)
      ansible.builtin.command:
        cmd: "git reset --hard origin/{{ git_branch | default('main') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_reset_result
      changed_when: true
      tags: [app, git-recovery]

    - name: Set git_result for recovery path
      ansible.builtin.set_fact:
        git_result:
          changed: true
          failed: false
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
        - git_reset_result is succeeded
      tags: [app, git-recovery]

    # =========================================================================
    # Normal Git Clone/Update - Runs when directory doesn't exist OR .git exists
    # =========================================================================

    - name: Clone repository
      ansible.builtin.git:
        repo: "{{ repo_url | default('https://github.com/smattymatty/storm-cloud-server.git') }}"
        dest: "{{ install_path }}"
        version: "{{ git_branch | default('main') }}"
        update: true
        force: true  # Safe: user data already migrated to /var/stormcloud/uploads/
      become_user: "{{ app_user }}"
      register: git_result
      when:
        - not (install_dir.stat.exists | default(false) and not (git_dir.stat.exists | default(false)))
      tags: [app]

    - name: Create directories
      ansible.builtin.file:
        path: "{{ install_path }}/{{ item }}"
        state: directory
        owner: "{{ app_user }}"
        mode: "0750"  # More secure: no world-read access
      loop: [uploads, backups]
      when: git_result is succeeded  # Only create if git clone succeeded
      tags: [app]

    # -------------------------------------------------------------------------
    # Secrets (managed via env vars/prompts at playbook start)
    # -------------------------------------------------------------------------

    - name: Check for existing .env
      ansible.builtin.stat:
        path: "{{ install_path }}/.env"
      register: env_check
      tags: [app, env]

    # Existing deploy: read and preserve secrets using custom dotenv parser
    - name: Read existing secrets from .env
      read_dotenv:
        path: "{{ install_path }}/.env"
        keys:
          - SECRET_KEY
          - POSTGRES_PASSWORD
          - STORAGE_ENCRYPTION_KEY
          - STORAGE_ENCRYPTION_METHOD
        required: false
      register: existing_secrets
      when: env_check.stat.exists
      tags: [app, env]

    - name: Preserve existing secrets (don't overwrite with new values)
      ansible.builtin.set_fact:
        secret_key: "{{ existing_secrets.values.SECRET_KEY }}"
        db_password: "{{ existing_secrets.values.POSTGRES_PASSWORD }}"
      when:
        - env_check.stat.exists
        - existing_secrets.values.SECRET_KEY is defined
        - existing_secrets.values.POSTGRES_PASSWORD is defined
      no_log: true
      tags: [app, env]

    - name: Use new secrets for first deployment or missing password
      ansible.builtin.set_fact:
        db_password: "{{ postgres_password }}"
      when: db_password is not defined
      no_log: true
      tags: [app, env]

    # -------------------------------------------------------------------------
    # Encryption Key Safety Checks (ADR 010)
    # Note: Key format validation happens early (before nginx/git) at line ~136
    # -------------------------------------------------------------------------

    - name: Check for encryption key mismatch (CRITICAL SAFETY CHECK)
      ansible.builtin.fail:
        msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          â›” ENCRYPTION KEY MISMATCH - DEPLOYMENT BLOCKED
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          The server has encryption ENABLED with an existing key, but you
          are deploying with a DIFFERENT key (or no key).

          This would make all encrypted files UNREADABLE!

          Options:
            1. Set the CORRECT key:
               export STORMCLOUD_ENCRYPTION_KEY="your-existing-key"

            2. If you lost the key and accept data loss, SSH to server and
               manually disable encryption in {{ install_path }}/.env

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      when:
        - env_check.stat.exists
        - existing_secrets.values.STORAGE_ENCRYPTION_KEY is defined
        - existing_secrets.values.STORAGE_ENCRYPTION_KEY | length > 0
        - storage_encryption_key != existing_secrets.values.STORAGE_ENCRYPTION_KEY
      tags: [app, env]

    - name: Warn if disabling encryption on encrypted server
      ansible.builtin.fail:
        msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          â›” CANNOT DISABLE ENCRYPTION - DEPLOYMENT BLOCKED
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          The server has encryption ENABLED, but you are deploying
          WITHOUT an encryption key (STORMCLOUD_ENCRYPTION_KEY not set).

          This would disable encryption and make existing files UNREADABLE!

          Options:
            1. Set your encryption key:
               export STORMCLOUD_ENCRYPTION_KEY="your-existing-key"

            2. If you intentionally want to disable encryption (DATA LOSS!),
               SSH to server and manually clear STORAGE_ENCRYPTION_KEY in
               {{ install_path }}/.env first.

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      when:
        - env_check.stat.exists
        - existing_secrets.values.STORAGE_ENCRYPTION_METHOD is defined
        - existing_secrets.values.STORAGE_ENCRYPTION_METHOD == 'server'
        - storage_encryption_key | length == 0
      tags: [app, env]

    # Belt-and-suspenders: Check actual files on disk, not just .env
    - name: Check for encrypted files on disk
      ansible.builtin.shell: |
        count=0
        for f in $(find {{ uploads_path | default('/var/stormcloud/uploads') }} -type f -size +16c 2>/dev/null | head -100); do
          first_byte=$(xxd -l 1 -p "$f" 2>/dev/null || echo "")
          [ "$first_byte" = "01" ] && count=$((count + 1))
          [ $count -ge 3 ] && break
        done
        echo $count
      register: encrypted_file_count
      changed_when: false
      failed_when: false
      tags: [app, env]

    - name: CRITICAL - Fail if encrypted files exist but no key provided
      ansible.builtin.fail:
        msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          CRITICAL: ENCRYPTED FILES DETECTED - NO KEY PROVIDED
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          Found {{ encrypted_file_count.stdout }} encrypted file(s) on disk,
          but STORMCLOUD_ENCRYPTION_KEY is empty.

          Deploying without the key will make ALL ENCRYPTED FILES UNREADABLE.

          Either:
            1. Set the correct encryption key:
               export STORMCLOUD_ENCRYPTION_KEY="your-existing-key"

            2. Or set in your local .env:
               STORAGE_ENCRYPTION_KEY=your-existing-key

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      when:
        - encrypted_file_count.stdout | default('0') | int > 0
        - storage_encryption_key | length == 0
      tags: [app, env]

    - name: Preserve existing encryption key (if not explicitly provided)
      ansible.builtin.set_fact:
        storage_encryption_key: "{{ existing_secrets.values.STORAGE_ENCRYPTION_KEY }}"
        storage_encryption_method: "{{ existing_secrets.values.STORAGE_ENCRYPTION_METHOD }}"
      when:
        - env_check.stat.exists
        - existing_secrets.values.STORAGE_ENCRYPTION_KEY is defined
        - existing_secrets.values.STORAGE_ENCRYPTION_KEY | length > 0
        - storage_encryption_key | length == 0
      no_log: true
      tags: [app, env]

    - name: Notify when enabling encryption for first time
      ansible.builtin.debug:
        msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          ðŸ” ENCRYPTION BEING ENABLED
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          You are enabling encryption for the first time on this server.

          âš ï¸  SAVE YOUR ENCRYPTION KEY SECURELY!

          If you lose this key, encrypted files will be UNRECOVERABLE.

          After deployment, encrypt existing files with:
            make encrypt-files

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      when:
        - storage_encryption_key | length > 0
        - not env_check.stat.exists or existing_secrets.values.STORAGE_ENCRYPTION_KEY is not defined or existing_secrets.values.STORAGE_ENCRYPTION_KEY | length == 0
      tags: [app, env]

    - name: Backup existing .env before overwriting
      ansible.builtin.copy:
        src: "{{ install_path }}/.env"
        dest: "{{ install_path }}/.env.backup.{{ ansible_date_time.iso8601_basic_short }}"
        remote_src: yes
        owner: "{{ app_user }}"
        mode: "0600"
      when: env_check.stat.exists
      tags: [app, env]

    - name: Write .env
      ansible.builtin.template:
        src: templates/dotenv.j2
        dest: "{{ install_path }}/.env"
        owner: "{{ app_user }}"
        mode: "0600"
      no_log: true  # Prevent secrets from appearing in logs
      tags: [app, env]

    # -------------------------------------------------------------------------
    # Docker
    # -------------------------------------------------------------------------

    - name: Build images
      ansible.builtin.command:
        cmd: docker compose build
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      # Always rebuild - Docker cache makes this fast when unchanged
      # Removed: when: git_result.changed (caused missed deploys)
      tags: [app, docker]

    - name: Start containers
      ansible.builtin.command:
        cmd: "docker compose up -d --remove-orphans"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      register: up_result
      changed_when: "'Started' in up_result.stdout or 'Creating' in up_result.stdout"
      tags: [app, docker]

    - name: Wait for healthy
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ _web_port }}/api/v1/health/ping/"
        status_code: 200
      register: health
      until: health.status == 200
      retries: 30
      delay: 2
      tags: [app, docker]

    # -------------------------------------------------------------------------
    # Post-Deploy Verification (data integrity check)
    # -------------------------------------------------------------------------

    - name: Count files in uploads after deploy
      ansible.builtin.find:
        paths: /var/stormcloud/uploads
        recurse: yes
        file_type: file
      become: true
      become_user: "{{ app_user }}"
      register: uploads_after_deploy
      tags: [app, validation]

    - name: Report uploads file count
      ansible.builtin.debug:
        msg: "âœ“ Uploads directory contains {{ uploads_after_deploy.matched }} files"
      tags: [app, validation]

    - name: Verify database connectivity
      ansible.builtin.command:
        cmd: docker compose exec -T app python manage.py check --database default
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      register: db_check
      failed_when: false
      changed_when: false
      tags: [app, validation]

    - name: Report database status
      ansible.builtin.debug:
        msg: "{{ 'âœ“ Database check passed' if db_check.rc == 0 else 'âš  Database check failed' }}"
      tags: [app, validation]

    # -------------------------------------------------------------------------
    # Done
    # -------------------------------------------------------------------------

    - name: Success
      ansible.builtin.debug:
        msg: |

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          âœ“ Deployed!
          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          Live at: https://{{ domain }}

          Next steps:

            ssh {{ ssh_user | default('root') }}@{{ server_ip }}
            su - {{ app_user }}
            cd {{ install_path }}
            make superuser
            make api_key

          â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      tags: [always]

    - name: CRITICAL - Save your encryption key!
      ansible.builtin.debug:
        msg: |

          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
          â–ˆâ–ˆ                                                          â–ˆâ–ˆ
          â–ˆâ–ˆ   SAVE YOUR ENCRYPTION KEY NOW!                          â–ˆâ–ˆ
          â–ˆâ–ˆ                                                          â–ˆâ–ˆ
          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

          Your encryption key is:

            {{ storage_encryption_key }}

          SAVE THIS TO A PASSWORD MANAGER RIGHT NOW!

          If you lose this key, ALL YOUR FILES WILL BE UNRECOVERABLE.

          This is your ONLY warning. The key will not be shown again.

          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

      when: storage_encryption_key | default('') | length > 0
      tags: [always]

  # ===========================================================================
  # HANDLERS
  # ===========================================================================

  handlers:
    - name: Reload nginx
      ansible.builtin.service:
        name: nginx
        state: reloaded
