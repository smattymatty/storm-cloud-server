# =============================================================================
# Storm Cloud Server - Deployment Playbook
# =============================================================================
#
# One-command deployment for Storm Cloud Server.
#
# Usage:
#   make deploy                    # From project root
#   make deploy-check              # Dry run (no changes)
#   make deploy-app                # Update app only
#
# Manual:
#   cd deploy/ansible
#   ansible-playbook playbook.yml -i inventory.yml --extra-vars "@../config.yml"
#
# =============================================================================

---
- name: Deploy Storm Cloud Server
  hosts: all
  become: true

  vars:
    app_user: "{{ app_user | default('stormcloud') }}"
    install_path: "/home/{{ app_user }}/storm-cloud-server"

  # ===========================================================================
  # PRE-FLIGHT
  # ===========================================================================

  pre_tasks:
    # Set default values for optional configuration variables
    # This prevents recursive template loops and makes defaults explicit
    - name: Set default values for optional variables
      ansible.builtin.set_fact:
        _web_port: "{{ web_port | default('8000') }}"
        _cors_origins: "{{ cors_origins | default('') }}"
        _max_upload_size_mb: "{{ max_upload_size_mb | default('100') }}"
      tags: [always]

    # -------------------------------------------------------------------------
    # Secret Resolution: Read from environment variables
    # -------------------------------------------------------------------------

    - name: Read secrets from environment variables
      ansible.builtin.set_fact:
        postgres_password: "{{ lookup('env', 'STORMCLOUD_POSTGRES_PASSWORD') }}"
        secret_key_input: "{{ lookup('env', 'STORMCLOUD_SECRET_KEY') }}"
      no_log: true
      tags: [always]

    - name: Auto-generate SECRET_KEY if not provided
      ansible.builtin.set_fact:
        secret_key_generated: "{{ lookup('password', '/dev/null length=50 chars=ascii_letters,digits,punctuation') }}"
      when: secret_key_input | default('') | length == 0
      no_log: true
      tags: [always]

    - name: Set final SECRET_KEY
      ansible.builtin.set_fact:
        secret_key: "{{ secret_key_input if (secret_key_input | default('') | length > 0) else secret_key_generated }}"
      no_log: true
      tags: [always]

    - name: Show auto-generated SECRET_KEY (save this somewhere safe!)
      ansible.builtin.debug:
        msg: |
          
          ══════════════════════════════════════════════════════════════
          ⚠️  AUTO-GENERATED SECRET_KEY
          ══════════════════════════════════════════════════════════════
          
          Your Django SECRET_KEY has been auto-generated:
          
          {{ secret_key }}
          
          ⚠️  SAVE THIS SOMEWHERE SAFE (password manager, encrypted file)
          
          To use the same key in future deployments:
            export STORMCLOUD_SECRET_KEY="{{ secret_key }}"
          
          ══════════════════════════════════════════════════════════════
      when: secret_key_input | default('') | length == 0
      tags: [always]

    - name: Validate config
      ansible.builtin.assert:
        that:
          - server_ip | default('') | length > 0
          - domain | default('') | length > 0
          - admin_email | default('') | length > 0
        fail_msg: |

          ══════════════════════════════════════════════════════════════
          ❌ Missing required config
          ══════════════════════════════════════════════════════════════
          
          Edit deploy/config.yml and set:

            server_ip:    {{ server_ip | default('(empty)') }}
            domain:       {{ domain | default('(empty)') }}
            admin_email:  {{ admin_email | default('(empty)') }}

          ══════════════════════════════════════════════════════════════
      tags: [always]

    - name: Validate secrets
      ansible.builtin.assert:
        that:
          - postgres_password | default('') | length > 0
          - secret_key | default('') | length > 0
        fail_msg: |

          ══════════════════════════════════════════════════════════════
          ❌ STORMCLOUD_POSTGRES_PASSWORD is required
          ══════════════════════════════════════════════════════════════

          Set secrets as environment variables before deploying:

            export STORMCLOUD_POSTGRES_PASSWORD="your-secure-password"
            export STORMCLOUD_SECRET_KEY="your-django-secret-key"  # Optional (will auto-generate)
            make deploy

          Or you will be prompted for them during deployment.

          Generate a secure password:
            openssl rand -base64 32

          Need help? See: deploy/README.md#secrets
          ══════════════════════════════════════════════════════════════
      tags: [always]

    - name: Check if nginx is already installed
      ansible.builtin.command: which nginx
      register: nginx_preinstalled
      failed_when: false
      changed_when: false
      tags: [always]

    - name: Detect existing nginx configurations
      ansible.builtin.find:
        paths: /etc/nginx/sites-enabled
        file_type: any
      register: existing_nginx_configs
      when: nginx_preinstalled.rc == 0
      tags: [always]

    - name: Warn about existing nginx installation
      ansible.builtin.pause:
        prompt: |

          ══════════════════════════════════════════════════════════════
          ⚠️  EXISTING NGINX INSTALLATION DETECTED
          ══════════════════════════════════════════════════════════════

          Found {{ existing_nginx_configs.matched | default(0) }} existing config(s) in /etc/nginx/sites-enabled/

          Storm Cloud will:
          1. Remove /etc/nginx/sites-enabled/default (if exists)
          2. Remove /etc/nginx/sites-enabled/stormcloud (old symlink without .conf)
          3. Create /etc/nginx/sites-enabled/stormcloud.conf

          ⚠️  Other existing configs will NOT be removed automatically.
          ⚠️  If you have CloudPanel or other control panels, conflicts may occur.

          The following configs currently exist:
          {% for item in existing_nginx_configs.files %}
            - {{ item.path }}
          {% endfor %}

          Press ENTER to continue or Ctrl+C then 'A' to abort...

      when:
        - nginx_preinstalled.rc == 0
        - existing_nginx_configs.matched | default(0) > 0
      tags: [always]

    - name: Show deployment info
      ansible.builtin.debug:
        msg: |

          ══════════════════════════════════════════════════════════════
          Deploying Storm Cloud Server

            Server:  {{ server_ip }}
            Domain:  {{ domain }}
            User:    {{ app_user }}
          ══════════════════════════════════════════════════════════════
      tags: [always]

  # ===========================================================================
  # ROLES
  # ===========================================================================

  roles:
    - role: geerlingguy.docker
      when: install_docker | default(true)
      vars:
        docker_users: ["{{ app_user }}"]
      tags: [docker]

  # ===========================================================================
  # TASKS
  # ===========================================================================

  tasks:
    # -------------------------------------------------------------------------
    # System
    # -------------------------------------------------------------------------

    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600
      tags: [system]

    - name: Install packages
      ansible.builtin.apt:
        name: [git, curl, ufw, acl]
        state: present
      tags: [system]

    - name: Create app user
      ansible.builtin.user:
        name: "{{ app_user }}"
        shell: /bin/bash
        groups: docker
        append: true
      tags: [system]

    - name: Create persistent data directories (outside git repo)
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: "{{ app_user }}"
        mode: "0750"
      loop:
        - /var/stormcloud
        - /var/stormcloud/uploads
        - /var/stormcloud/backups
      tags: [system, app]

    # -------------------------------------------------------------------------
    # Firewall
    # -------------------------------------------------------------------------

    - name: Allow SSH
      community.general.ufw:
        rule: allow
        name: OpenSSH
      when: configure_firewall | default(true)
      tags: [firewall]

    - name: Allow HTTP
      community.general.ufw:
        rule: allow
        port: "80"
      when: configure_firewall | default(true)
      tags: [firewall]

    - name: Allow HTTPS
      community.general.ufw:
        rule: allow
        port: "443"
      when: configure_firewall | default(true)
      tags: [firewall]

    - name: Enable firewall
      community.general.ufw:
        state: enabled
        policy: deny
      when: configure_firewall | default(true)
      tags: [firewall]

    # -------------------------------------------------------------------------
    # Nginx (initial)
    # -------------------------------------------------------------------------

    - name: Install nginx
      ansible.builtin.apt:
        name: nginx
        state: present
      when: install_nginx | default(true)
      tags: [nginx]

    - name: Create certbot webroot
      ansible.builtin.file:
        path: /var/www/certbot
        state: directory
        mode: "0755"
      tags: [nginx]

    - name: Check if SSL cert exists
      ansible.builtin.stat:
        path: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      register: ssl_cert
      tags: [nginx, ssl]

    - name: Deploy pre-SSL nginx config
      ansible.builtin.copy:
        dest: /etc/nginx/sites-available/stormcloud
        mode: "0644"
        content: |
          server {
              listen 80;
              server_name {{ domain }};

              location /.well-known/acme-challenge/ {
                  root /var/www/certbot;
              }

              location / {
                  return 200 'Storm Cloud - awaiting SSL\n';
                  add_header Content-Type text/plain;
              }
          }
      when:
        - install_nginx | default(true)
        - not ssl_cert.stat.exists | default(true)
      notify: Reload nginx
      tags: [nginx]

    - name: Enable site
      ansible.builtin.file:
        src: /etc/nginx/sites-available/stormcloud
        dest: /etc/nginx/sites-enabled/stormcloud.conf
        state: link
      when: install_nginx | default(true)
      notify: Reload nginx
      tags: [nginx]

    - name: Remove default site
      ansible.builtin.file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: Reload nginx
      tags: [nginx]

    - name: Remove old stormcloud symlink (without .conf extension)
      ansible.builtin.file:
        path: /etc/nginx/sites-enabled/stormcloud
        state: absent
      notify: Reload nginx
      tags: [nginx]

    - name: Start nginx
      ansible.builtin.service:
        name: nginx
        state: started
        enabled: true
      when: install_nginx | default(true)
      tags: [nginx]

    - name: Flush handlers for certbot
      ansible.builtin.meta: flush_handlers
      tags: [nginx, ssl]

    # -------------------------------------------------------------------------
    # SSL
    # -------------------------------------------------------------------------

    - name: Install certbot
      ansible.builtin.apt:
        name: [certbot, python3-certbot-nginx]
        state: present
      when: install_certbot | default(true)
      tags: [ssl]

    - name: Get SSL certificate
      ansible.builtin.command:
        cmd: >-
          certbot certonly --webroot
          --webroot-path=/var/www/certbot
          --email {{ admin_email }}
          --agree-tos --no-eff-email --non-interactive
          -d {{ domain }}
        creates: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      when: install_certbot | default(true)
      tags: [ssl]

    - name: Re-check SSL cert
      ansible.builtin.stat:
        path: "/etc/letsencrypt/live/{{ domain }}/fullchain.pem"
      register: ssl_cert_final
      tags: [nginx, ssl]

    - name: Deploy full nginx config
      ansible.builtin.template:
        src: templates/nginx-stormcloud.conf.j2
        dest: /etc/nginx/sites-available/stormcloud
        mode: "0644"
      when:
        - install_nginx | default(true)
        - ssl_cert_final.stat.exists
      notify: Reload nginx
      tags: [nginx, ssl]

    # -------------------------------------------------------------------------
    # Application
    # -------------------------------------------------------------------------

    - name: Check if git repo exists
      ansible.builtin.stat:
        path: "{{ install_path }}/.git"
      become: true  # Need elevated permissions to check ownership
      register: git_dir
      tags: [app]

    - name: Check if install directory exists
      ansible.builtin.stat:
        path: "{{ install_path }}"
      become: true  # Need elevated permissions to check ownership
      register: install_dir
      tags: [app]

    # ADD THIS RIGHT HERE
    - name: DEBUG stat results
      ansible.builtin.debug:
        var: install_dir
      tags: [app]

    # =========================================================================
    # Git Recovery - Handle broken deployment states
    # =========================================================================
    # If directory exists but .git is missing, we have a partial deployment.
    # Instead of nuking the directory (losing .env, uploads/),
    # we initialize git in-place and hard reset to the target branch.
    # =========================================================================

    - name: Fix directory ownership (if owned by root)
      ansible.builtin.file:
        path: "{{ install_path }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        recurse: true
      become: true
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
        - install_dir.stat.pw_name is defined and install_dir.stat.pw_name == 'root'
      tags: [app, git-recovery]

    - name: Initialize git repository (recovery mode)
      ansible.builtin.command:
        cmd: git init
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_init_result
      changed_when: "'Initialized' in git_init_result.stdout or 'Reinitialized' in git_init_result.stdout"
      tags: [app, git-recovery]

    - name: Add remote origin (recovery mode)
      ansible.builtin.command:
        cmd: "git remote add origin {{ repo_url | default('https://github.com/smattymatty/storm-cloud-server.git') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_remote_result
      failed_when: false  # Ignore error if remote already exists
      changed_when: git_remote_result.rc == 0
      tags: [app, git-recovery]

    - name: Set remote URL (if remote already existed)
      ansible.builtin.command:
        cmd: "git remote set-url origin {{ repo_url | default('https://github.com/smattymatty/storm-cloud-server.git') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
        - git_remote_result is defined and git_remote_result.rc != 0
      tags: [app, git-recovery]

    - name: Fetch from remote (recovery mode)
      ansible.builtin.command:
        cmd: "git fetch origin {{ git_branch | default('main') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_fetch_result
      changed_when: true
      tags: [app, git-recovery]

    - name: Hard reset to target branch (recovery mode)
      ansible.builtin.command:
        cmd: "git reset --hard origin/{{ git_branch | default('main') }}"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
      register: git_reset_result
      changed_when: true
      tags: [app, git-recovery]

    - name: Set git_result for recovery path
      ansible.builtin.set_fact:
        git_result:
          changed: true
          failed: false
      when:
        - install_dir.stat.exists | default(false)
        - not (git_dir.stat.exists | default(false))
        - git_reset_result is succeeded
      tags: [app, git-recovery]

    # =========================================================================
    # Normal Git Clone/Update - Runs when directory doesn't exist OR .git exists
    # =========================================================================

    - name: Clone repository
      ansible.builtin.git:
        repo: "{{ repo_url | default('https://github.com/smattymatty/storm-cloud-server.git') }}"
        dest: "{{ install_path }}"
        version: "{{ git_branch | default('main') }}"
        update: true
      become_user: "{{ app_user }}"
      register: git_result
      when:
        - not (install_dir.stat.exists | default(false) and not (git_dir.stat.exists | default(false)))
      tags: [app]

    - name: Create directories
      ansible.builtin.file:
        path: "{{ install_path }}/{{ item }}"
        state: directory
        owner: "{{ app_user }}"
        mode: "0750"  # More secure: no world-read access
      loop: [uploads, backups]
      when: git_result is succeeded  # Only create if git clone succeeded
      tags: [app]

    # -------------------------------------------------------------------------
    # Secrets (managed via env vars/prompts at playbook start)
    # -------------------------------------------------------------------------

    - name: Check for existing .env
      ansible.builtin.stat:
        path: "{{ install_path }}/.env"
      register: env_check
      tags: [app, env]

    # Existing deploy: read and preserve secrets using custom dotenv parser
    - name: Read existing secrets from .env
      read_dotenv:
        path: "{{ install_path }}/.env"
        keys:
          - SECRET_KEY
          - POSTGRES_PASSWORD
        required: false
      register: existing_secrets
      when: env_check.stat.exists
      tags: [app, env]

    - name: Preserve existing secrets (don't overwrite with new values)
      ansible.builtin.set_fact:
        secret_key: "{{ existing_secrets.values.SECRET_KEY }}"
        db_password: "{{ existing_secrets.values.POSTGRES_PASSWORD }}"
      when:
        - env_check.stat.exists
        - existing_secrets.values.SECRET_KEY is defined
        - existing_secrets.values.POSTGRES_PASSWORD is defined
      no_log: true
      tags: [app, env]

    - name: Use new secrets for first deployment or missing password
      ansible.builtin.set_fact:
        db_password: "{{ postgres_password }}"
      when: db_password is not defined
      no_log: true
      tags: [app, env]

    - name: Write .env
      ansible.builtin.template:
        src: templates/dotenv.j2
        dest: "{{ install_path }}/.env"
        owner: "{{ app_user }}"
        mode: "0600"
      no_log: true  # Prevent secrets from appearing in logs
      tags: [app, env]

    # -------------------------------------------------------------------------
    # Docker
    # -------------------------------------------------------------------------

    - name: Build images
      ansible.builtin.command:
        cmd: docker compose build
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      # Always rebuild - Docker cache makes this fast when unchanged
      # Removed: when: git_result.changed (caused missed deploys)
      tags: [app, docker]

    - name: Start containers
      ansible.builtin.command:
        cmd: "docker compose up -d --remove-orphans"
        chdir: "{{ install_path }}"
      become_user: "{{ app_user }}"
      register: up_result
      changed_when: "'Started' in up_result.stdout or 'Creating' in up_result.stdout"
      tags: [app, docker]

    - name: Wait for healthy
      ansible.builtin.uri:
        url: "http://127.0.0.1:{{ _web_port }}/api/v1/health/ping/"
        status_code: 200
      register: health
      until: health.status == 200
      retries: 30
      delay: 2
      tags: [app, docker]

    # -------------------------------------------------------------------------
    # Done
    # -------------------------------------------------------------------------

    - name: Success
      ansible.builtin.debug:
        msg: |

          ══════════════════════════════════════════════════════════════
          ✓ Deployed!
          ══════════════════════════════════════════════════════════════

          Live at: https://{{ domain }}

          Next steps:

            ssh {{ ssh_user | default('root') }}@{{ server_ip }}
            su - {{ app_user }}
            cd {{ install_path }}
            make superuser
            make api_key

          ══════════════════════════════════════════════════════════════
      tags: [always]

  # ===========================================================================
  # HANDLERS
  # ===========================================================================

  handlers:
    - name: Reload nginx
      ansible.builtin.service:
        name: nginx
        state: reloaded
